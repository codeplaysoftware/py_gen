#   Copyright (C) Codeplay Software Limited.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use these files except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   For your convenience, a copy of the License has been included in this
#   repository.
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

from itertools import (combinations, combinations_with_replacement,
                       permutations, product)
from string import Template
from ..iter_classes import Itermode, Iterable

# Each gen function calls the method safe_substitute on the input template with
# each result of the combinatoric generator method. The combinatoric generators
# are methods provided by python for generating combinations, permutations and
# products of a set of values. The results of the calls to safe_substitute are
# appended in order to a string, which is returned as a new template.


def gen_combinations(template, iterable):
    """Generates combinations based on the given iterable and inserts them in
    the template. The result is returned as a new string Template."""
    result_str = ''
    key = iterable.key
    for comb in combinations(iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            comb = ', '.join(comb)
        else:
            comb = ''.join(comb)
        result_str += template.safe_substitute(**{key: comb})
    return Template(result_str)


def gen_combinations_with_replacement(template, iterable):
    """Generates combinations with replacement based on the given iterable and
    inserts them in the template. The result is returned as a new string
    Template."""
    result_str = ''
    key = iterable.key
    for combWR in combinations_with_replacement(
            iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            combWR = ', '.join(combWR)
        else:
            combWR = ''.join(combWR)
        result_str += template.safe_substitute(**{key: combWR})
    return Template(result_str)


def gen_permutations(template, iterable):
    """Generates permutations based on the given iterable and inserts them in
    the template. The result is returned as a new string Template."""
    result_str = ''
    key = iterable.key
    for perm in permutations(iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            perm = ', '.join(perm)
        else:
            perm = ''.join(perm)
        result_str += template.safe_substitute(**{key: perm})
    return Template(result_str)


def gen_product(template, iterable):
    """Generates products based on the given iterable and inserts them in the
    template. The result is returned as a new string Template."""
    result_str = ''
    key = iterable.key
    for prod in product(iterable.vals, repeat=iterable.iter_modifier):
        if iterable.comma_list:
            prod = ', '.join(prod)
        else:
            prod = ''.join(prod)
        result_str += template.safe_substitute(**{key: prod})
    return Template(result_str)


def dispatch_iterations(template, iterables):
    """Iterates through the input list of iterables in order, checking the
    Itermode of each iterable and dispatching the template and iterable to the
    correct gen method. The generated template is used as the template for the
    next iteration, and so on. Once all iterables have been used the resulting
    template is returned."""
    result_template = template
    # Iterate over each iterable in
    for iterable in iterables:
        iterT = iterable.itermode
        # Check the Itermode of the iterable and dispatch the correct call
        if iterT is Itermode.combinations:
            result_template = gen_combinations(result_template, iterable)
        elif iterT is Itermode.combinationsWR:
            result_template = gen_combinations_with_replacement(
                result_template, iterable)
        elif iterT is Itermode.permutations:
            result_template = gen_permutations(result_template, iterable)
        elif iterT is Itermode.product:
            result_template = gen_product(result_template, iterable)
        else:
            print('Dispatch for Itermode ' + iterT + ' is not supported')
    return result_template


def gen_combinations_list(iterable):
    """Builds and returns tuple of the input iterables key, and a list of all
    the combinations generated by the iterable."""
    comb_list = []
    for comb in combinations(iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            comb_list.append(', '.join(comb))
        else:
            comb_list.append(''.join(comb))
    return (iterable.key, comb_list)


def gen_combinations_with_replacement_list(iterable):
    """Builds and returns tuple of the input iterables key, and a list of all
    the combinations with replacement generated by the iterable."""
    combWR_list = []
    for combWR in combinations_with_replacement(
            iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            combWR_list.append(', '.join(combWR))
        else:
            combWR_list.append(''.join(combWR))
    return (iterable.key, combWR_list)


def gen_permutations_list(iterable):
    """Builds and returns tuple of the input iterables key, and a list of all
    the permutations generated by the iterable."""
    perm_list = []
    for perm in permutations(iterable.vals, r=iterable.iter_modifier):
        if iterable.comma_list:
            perm_list.append(', '.join(perm))
        else:
            perm_list.append(''.join(perm))
    return (iterable.key, perm_list)


def gen_product_list(iterable):
    """Builds and returns tuple of the input iterables key, and a list of all
    the products generated by the iterable."""
    prod_list = []
    for prod in product(iterable.vals, repeat=iterable.iter_modifier):
        if iterable.comma_list:
            prod_list.append(', '.join(prod))
        else:
            prod_list.append(''.join(prod))
    return (iterable.key, prod_list)


def combined_dispatcher(template, iterables):
    """Iterates through the input list of iterables, collecting all of their
    outputs in a list of tuples of form (iterable.key, [output1, output2,...]).
    Then iterates over the output lists in parallel, substituting the first
    result of each, then the second, and so on. Returns the resulting template.
    """
    iter_list = []
    for iterable in iterables:
        iterT = iterable.itermode
        if iterT is Itermode.combinations:
            iter_list.append(gen_combinations_list(iterable))
        if iterT is Itermode.combinationsWR:
            iter_list.append(gen_combinations_with_replacement_list(iterable))
        if iterT is Itermode.permutations:
            iter_list.append(gen_permutations_list(iterable))
        if iterT is Itermode.product:
            iter_list.append(gen_product_list(iterable))
    template_str = template.template
    res = template
    iter_count = len(iter_list[0][1])
    for index in range(0, iter_count):
        for iterable in iter_list:
            res = Template(
                res.safe_substitute(**{iterable[0]: iterable[1][index]}))
        if index != iter_count - 1:
            res = Template(res.template + template_str)
    return res


def removal_dispatcher(template, in_iterables, removal_iterables):
    """First iterates through the list of iterables 'removal_iterables'. Stores
    each output from these iterables for later. Then iterates through the list
    'in_iterables', removing any output which is present in the output of
    'removal_iterables'. Safe substitutes the output after removal into the
    template, one iterable at a time."""
    # Build the removal list
    removal_list = []
    for iterable in removal_iterables:
        iterT = iterable.itermode
        if iterT is Itermode.combinations:
            for output in gen_combinations_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.combinationsWR:
            for output in gen_combinations_with_replacement_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.permutations:
            for output in gen_permutations_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.product:
            for output in gen_product_list(iterable)[1]:
                removal_list.append(output)
    # Iterate over the in_iterables
    res = template
    res_str = template.template
    for iterable in in_iterables:
        res = Template(res_str)
        output_list = []
        iterT = iterable.itermode
        if iterT is Itermode.combinations:
            for output in gen_combinations_list(iterable)[1]:
                output_list.append(output)
        if iterT is Itermode.combinationsWR:
            for output in gen_combinations_with_replacement_list(iterable)[1]:
                output_list.append(output)
        if iterT is Itermode.permutations:
            for output in gen_permutations_list(iterable)[1]:
                output_list.append(output)
        if iterT is Itermode.product:
            for output in gen_product_list(iterable)[1]:
                output_list.append(output)
        # Remove anything generated that is also contained in the removal list
        output_list = [x for x in output_list if x not in removal_list]
        res_str = ''
        # Safe substitute the remaining outputs
        for output in output_list:
            res_str += res.safe_substitute(**{iterable.key: output})
    res = Template(res_str)
    return res


def combined_removal_dispatcher(template, in_iterables, removal_iterables):
    """First iterates through the list of iterables 'removal_iterables'. Stores
    each output from these iterables for later. Then iterates through the list
    'in_iterables', saving their outputs in the form (key, [output, output,..]).
    Next, iterates over the output lists in parallel, ignoring any combination
    which includes an element of the removal list. The non-removed combined
    outputs are safe substituted into the template, which is finally returned.
    """
    # Build the removal list
    removal_list = []
    for iterable in removal_iterables:
        iterT = iterable.itermode
        if iterT is Itermode.combinations:
            for output in gen_combinations_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.combinationsWR:
            for output in gen_combinations_with_replacement_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.permutations:
            for output in gen_permutations_list(iterable)[1]:
                removal_list.append(output)
        if iterT is Itermode.product:
            for output in gen_product_list(iterable)[1]:
                removal_list.append(output)
    # Build the iterable list in form [(key, [output, output, ...]),...]
    iter_list = []
    for iterable in in_iterables:
        iterT = iterable.itermode
        if iterT is Itermode.combinations:
            iter_list.append(gen_combinations_list(iterable))
        if iterT is Itermode.combinationsWR:
            iter_list.append(gen_combinations_with_replacement_list(iterable))
        if iterT is Itermode.permutations:
            iter_list.append(gen_permutations_list(iterable))
        if iterT is Itermode.product:
            iter_list.append(gen_product_list(iterable))
    # Lambda that checks if any element of list a is in list b
    any_in = lambda a, b: any(i in b for i in a)
    template_str = template.template
    res = template
    # Loop over generated iterable list
    iter_count = len(iter_list[0][1])
    for index in range(0, iter_count):
        test_list = []
        output_list = []
        for iterable in iter_list:
            test_list.append(iterable[1][index])
            output_list.append(iterable)
        if not any_in(test_list, removal_list):
            for iterable in output_list:
                res = Template(
                    res.safe_substitute(**{iterable[0]: iterable[1][index]}))
            if index != iter_count - 1:
                res = Template(res.template + template_str)
    return res
